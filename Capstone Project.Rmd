---
title: "Data Science Specialization Capstone Project"
author: "Alejandro Osorio"
date: "September 2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set
library(tidyverse)
library(stringr)
```

## I. Appendix 1: Getting and Cleaning Data

### I.a. Reading Data

#### Twitter Dataset
```{r, echo = TRUE}
con <- file("en_US.twitter.txt", "r")
datatwitter <- data_frame(TEXT = readLines(con))
close(con)
```

Given the warning, the dimensions of both the obtained tibble and the original file, were compared.  They were equal.  Additionally, after some basic visual comparisons (head, tail, str, is.na), it was concluded that the obtained tibble was ok to work with.

#### Blogs Dataset
```{r, echo = TRUE}
con <- file("en_US.blogs.txt", "r")
datablogs <- data_frame(TEXT = readLines(con))
close(con)
```

After the same basic visual comparisons (head, tail, str, is.na) used with the previous dataset, it was concluded that the obtained tibble was also ok to work with.

#### News Dataset
```{r, echo = TRUE}
con <- file("en_US.news.txt", "r")
datanews_err <- data_frame(TEXT = readLines(con))
close(con)
```

Given the warning, the dimensions of both the obtained tibble and the original file, were compared.  The total number of lines obtained with the tibble (77,259) were much less than the ones from the original txt file (1,010,242).  Therefore, some cleaning was required, as follows.

### I.b. Cleaning Data

Further analysis to the "news" dataset, showed that line 77,259 was cut at the character "1", when compared to the one from the original file ("Ultra Edit" text editor was used for reading the original dataset, as well as the next cleaning steps). Therefore line 77,259 was analysed and an EOF character was found between texts "1" and "gallons", within the phrase "producing 1 -EOF- gallons".  Said character was deleted and the process re-run.  The result was a tibble with 766,277 rows (still less than the original file).  Another EOF character was found in row 766.277 (between texts "in" and "- inch", within the phrase "pears in EOF - inch slices."), deleted and the process re-run. Again, fewer rows were obtained (926,143).  Yet another EOF character was found in row 926,143 (between texts "in" and "-inch" within the phrase "Slice in EOF -inch-thick pieces"), deleted and the process re-run. Still, but last, fewer rows were obtained (948,564).  EOF character was found in row 926,143 (between texts "1" and "pounds" within the phrase "call for 1 EOF pounds of tomatoes"), deleted and the process re-run again.  Finally, 1,010,242 lines were obtained from the final fixed file, as follows:

```{r, echo = TRUE}
con <- file("en_US.news_FINAL.txt", "r")
datanews <- data_frame(TEXT = readLines(con))
close(con)
glimpse(datanews)
```

With this result, plus the same basic visual comparisons (head, tail, str, is.na) used with the previous datasets, it was concluded that the obtained tibble was also ok to work with and therefore the cleaning stage was considered finished.

### I.c. Preparing Preliminary Datasets

In order to work with sets words, each line of the obtained datasets was converted into a list of separate-underscore-words, as follows:

```{r, echo = TRUE}
words_twitter <- datatwitter$TEXT %>%
        str_to_lower() %>%
        str_extract_all(., boundary("word"))
words_blogs <- datablogs$TEXT %>%
        str_to_lower() %>%
        str_extract_all(., boundary("word"))
words_news <- datanews$TEXT %>%
        str_to_lower() %>%
        str_extract_all(., boundary("word"))
```

An example of the results obtained:

```{r}
head(words_twitter, 2)
```

## II, Appendix 2: Preliminary Analysis

### II.a. Basic Analysis Functions

#### Single row word frequency counter

Function that returns a dataframe with two columns (unique word and its frequency within given row).

```{r}
wordrowfreq <- function(dataset, rownum) {
        rowfreq <- data_frame(word = character(), freq = numeric())
        uniquewordsrow <- unique(dataset[[rownum]])
        for(i in seq_along(uniquewordsrow)) {
                uniqueword <- paste("\\b", uniquewordsrow[i], "\\b", sep = "")
                uniquewordfreq <- str_count(dataset[rownum], uniqueword)
                rowfreq[i,1] <- uniquewordsrow[i]
                rowfreq[i,2] <- uniquewordfreq
        }
        return(rowfreq)
}
```

As an example follows an extract of the results obtained using 3rd row of news data:

```{r}
head(wordrowfreq(dataset = words_news, rownum = 3), 3)
```

#### Multirow word frequency counter

Function that nested the previous function, within a loop along the length of the dataset.  The returned dataset (wordfrequency) was grouped by words, summarized and arranged by frequency in order to easily visualize the most frequent words within each dataset.

```{r}
wordsetfreq <- function(dataset) {
        setfreq <- data_frame(word = character(), freq = numeric())
        for(i in seq_along(dataset)) {
               setfreq <- bind_rows(setfreq, wordrowfreq(dataset, rownum = i))
        }
        setfreq <- setfreq %>%
                group_by(word) %>%
                summarize (., freq = sum(freq)) %>%
                arrange(., desc(freq))
        return(setfreq)
}
```

As an example follows an extract of the results obtained using rows 1 through 3 of news data:

```{r}
head(wordsetfreq(dataset = words_news[1:3]), 3)
```

#### Single row 2-grams generator

Function that returns a dataframe with all 2-grams per row

```{r}
twogramrow <- function(dataset, rownum) {
        twograms <- data_frame(twograms = character())
        if(length(dataset[[rownum]]) < 2) {
                twograms <- NA
        } else {
                qngrams <- length(dataset[[rownum]])-1
                for(j in 1:qngrams) {
                        twograms[j,1] <- paste(dataset[[rownum]][[j]], dataset[[rownum]][[j+1]], sep = " ")
                }
        }
        return(twograms)
}
```

As an example follows an extract of the results obtained using 3rd row of news data:

```{r}
head(twogramrow(dataset = words_news, rownum = 3), 3)
```

#### Single row 3-grams generator

Function that returns a list of 3-grams per row

```{r}
threegramrow <- function(dataset, rownum) {
        threegrams <- data_frame(threegrams = character())
        if(length(dataset[[rownum]]) < 3) {
                threegrams <- NA
        } else {
                qngrams <- length(dataset[[rownum]])-2
                for(j in 1:qngrams) {
                        threegrams[j,1] <- paste(dataset[[rownum]][[j]], dataset[[rownum]][[j+1]], dataset[[rownum]][[j+2]], sep = " ")
                }
        }
        return(threegrams)
}
```

As an example follows an extract of the results obtained using 3rd row of news data:

```{r}
head(threegramrow(dataset = words_news, rownum = 3), 3)
```

#### Multirow 2-grams frequency counter

Function that returns a dataframe with two columns (2-grams and their frequency within given dataset).

```{r}

```

### II.b. Results Obtained by Dataset

#### Twitter dataset

Once the word frequency function was applied to the first 1,000 rows of the dataset, the following result was obtained.

```{r, echo = TRUE}
freqword_twitter <- wordsetfreq(dataset = words_twitter[1:1000])
head(freqword_twitter)

```

#### Blogs dataset

Likewise, the following result was obtained.

```{r, echo = TRUE}
freqword_blogs <- wordsetfreq(dataset = words_blogs[1:1000])
head(freqword_blogs)

```

#### News dataset

Finally, the following result was obtained for the news dataset.

```{r, echo = TRUE}
freqword_news <- wordsetfreq(dataset = words_news[1:1000])
head(freqword_news)

```

Worth noting that words such as "the", "to", "a", "and" were the most frequent ones throughout all datasets.


